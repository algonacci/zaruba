includes:
  - ./core.generator.zaruba.yaml
  - ./core.run.zaruba.yaml
  - ./core.service.zaruba.yaml
  - ./core.setup.zaruba.yaml

tasks:

  core.showAdv:
    icon: ‚òï
    private: true
    extend: core.runCoreScript
    dependencies:
    - core.setupPyUtil
    logless: true
    config:
      start: |
        {{ if .GetKwarg "hideAdvertisement" }}{{ else }}sh "${PY_UTIL}" show_advertisement{{ end }}


  showVersion:
    icon: üîé
    description: |
      Show zaruba's current version.
      USAGE: zaruba please showVersion
    extend: core.runCoreScript
    config:
      start: |
        {{ $d := .Decoration -}}
        echo "{{ $d.Bold }}{{ $d.Yellow }}Current version: $(sh "${UTIL}/get_latest_git_tag.sh") - $(sh "${UTIL}/get_latest_git_commit.sh"){{ $d.Normal }}"


  update:
    icon: üîÑ
    description: |
      Update zaruba to the latest version.
      USAGE: zaruba please update
    extend: core.runCoreScript
    config:
      start: |
        {{ $d := .Decoration -}}
        cd ${ZARUBA_HOME}
        echo "üîΩ {{ $d.Bold }}{{ $d.Yellow }}Pull zaruba{{ $d.Normal }}"
        git pull origin master
        git fetch origin --tags
        echo "üöß {{ $d.Bold }}{{ $d.Yellow }}Compile zaruba{{ $d.Normal }}"
        go build
        echo üéâüéâüéâ
        echo "{{ $d.Bold }}{{ $d.Yellow }}Zaruba ready!!!{{ $d.Normal }}"
        {{ $showVersion := .GetTask "core.showVersion" -}}
        {{ $showVersion.GetConfig "start" }}


  serveHttp:
    icon: üåê
    description: |
      Run static web server from your working directory.
      USAGE: zaruba please serveHttp [port=port]
      ARGUMENTS:
        port: HTTP Port, default to 8000
    extend: core.startService
    lconfig:
      ports: ['{{ if .GetKwarg "port" }}{{ .GetKwarg "port" }}{{ else }}8000{{ end }}']
    start: 
    - python 
    - "-m"
    - http.server
    - '{{ $ports := .GetLConfig "ports" }}{{ index $ports 0 }}'


  clearLog:
    icon: üî•
    description: |
      Clear log
    extend: core.runCoreScript
    config:
      start: |
        {{ $d := .Decoration -}}
        rm -Rf log.zaruba.csv
        echo "{{ $d.Bold }}{{ $d.Yellow }}Log removed{{ $d.Normal }}"


  showLog:
    icon: üîé
    description: |
      Show log for all/particular tasks using regex
      USAGE:
        zaruba please showLog
        zaruba please showLog task="test.*"
      ARGUMENTS:
        task: task regex pattern, default to '.*'
    extend: core.runCoreScript
    dependencies:
    - core.setupPyUtil
    logless: true
    config:
      start: |
        {{ $d := .Decoration -}}
        sh "${UTIL}/should_be_file.sh" "log.zaruba.csv" "{{ $d.Bold }}{{ $d.Red }}Log is not exist{{ $d.Normal }}"
        TASK="{{ if .GetKwarg "task" }}{{ .GetKwarg "task" }}{{ else }}.*{{ end }}"
        sh "${PY_UTIL}" show_log "log.zaruba.csv" "${TASK}"


  core.isValidSubrepos:
    icon: üîç
    private: true
    extend: core.runCoreScript
    config:
      start: |
        {{ $d := .Decoration -}}
        {{ $names := .GetKwargSubKeys "subrepo" -}}
        {{ $this := . -}}
        {{ range $index, $name := $names -}}
          PREFIX="{{ $this.GetKwarg "subrepo" $name "prefix" }}"
          URL="{{ $this.GetKwarg "subrepo" $name "url" }}"
          NAME="{{ $name }}"
          sh "${UTIL}/should_not_be_empty.sh" "${URL}" "{{ $d.Bold }}{{ $d.Red }}Subrepo ${NAME} doesn't have url{{ $d.Normal }}"
          sh "${UTIL}/should_not_be_empty.sh" "${PREFIX}" "{{ $d.Bold }}{{ $d.Red }}Subrepo ${NAME} doesn't have prefix{{ $d.Normal }}"
        {{ end }}
        echo "{{ $d.Bold }}{{ $d.Yellow }}All Subrepos are valid{{ $d.Normal }}"


  initSubrepos:
    icon: üì¶
    description: |
      Init subrepositories.
      USAGE:
        zaruba please initSubrepos
        zaruba please initSubrepos "subrepo::fibo::url=https://github.com/therealvasanth/fibonacci-clock"
      ARGUMENTS:
        subrepo::<name>::prefix: Prefix (directory name) of the subrepo
        subrepo::<name>::url:    Remote url of the subrepo
        subrepo::<name>::name:   Origin name of the subrepo
      TIPS:
        It is recommended to put `subrepo` arguments in `default.kwargs.yaml`.
        In order to do that, you can invoke `zaruba please addSubrepo <url=remote-url>`
    extend: core.runCoreScript
    dependencies:
    - core.isProject
    - core.isValidSubrepos
    - core.setupPyUtil
    config:
      start: |
        {{ $d := .Decoration -}}
        {{ $names := .GetKwargSubKeys "subrepo" -}}
        {{ $this := . -}}
        BRANCH="{{ if .GetKwarg "defaultBranch" }}{{ .GetKwarg "defaultBranch" }}{{ else }}main{{ end }}"
        ORIGINS=$(git remote)
        {{ range $index, $name := $names -}}
          PREFIX="{{ $this.GetKwarg "subrepo" $name "prefix" }}"
          URL="{{ $this.GetKwarg "subrepo" $name "url" }}"
          NAME="{{ $name }}"
          ORIGIN_EXISTS=$(sh "${PY_UTIL}" is_in_array "${NAME}" ${ORIGINS})
          if [ $ORIGIN_EXISTS = 1 ]
          then
            git remote set-url "${NAME}" "${URL}"
          elif [ $ORIGIN_EXISTS = 0 ]
          then
            echo "$NAME origin is not exist"
            sh "${UTIL}/git_save.sh" "Save works before pulling from ${URL}"
            PREFIX_EXISTS=0
            if [ -d "$PREFIX" ]
            then
              PREFIX_EXISTS=1
              mv "${PREFIX}" "${PREFIX}.bak"
              sh "${UTIL}/git_save.sh" "Temporarily move ${PREFIX}"
            fi
            sh "${UTIL}/git_init_subrepo.sh" "${NAME}" "${PREFIX}" "${URL}" "${BRANCH}"
            if [ $PREFIX_EXISTS = 1 ]
            then
              rm -Rf "${PREFIX}"
              mv "${PREFIX}.bak" "${PREFIX}"
              sh "${UTIL}/git_save.sh" "Restore ${PREFIX}"
            fi
          fi
        {{ end -}}
        echo üéâüéâüéâ
        echo "{{ $d.Bold }}{{ $d.Yellow }}Subrepos Initialized{{ $d.Normal }}"


  addSubrepo:
    icon: ü•Ç
    description: |
      Add subrepository.
      USAGE:
        zaruba please addSubrepo url=https://github.com/therealvasanth/fibonacci-clock
        zaruba please addSubrepo url=https://github.com/therealvasanth/fibonacci-clock name=fibo prefix=fibo
      ARGUMENTS:
        url:    Remote url of the subrepo. (required)
        prefix: Prefix (directory name) of the subrepo. (optional)
        name:   Origin name of the subrepo. (optional)
      TIPS:
        To init subrepositories, you should perform `zaruba please initSubrepos`
    extend: core.runCoreScript
    dependencies:
    - core.isProject
    - core.setupPyUtil
    config:
      start: |
        {{ $d := .Decoration -}}
        URL="{{ .GetKwarg "url" }}"
        sh "${UTIL}/should_not_be_empty.sh" "${URL}" "{{ $d.Bold }}{{ $d.Red }}Subrepo url is not defined{{ $d.Normal }}"
        {{ if .GetKwarg "prefix" }}
          PREFIX="{{ .GetKwarg "prefix" }}"
        {{ else }}
          PREFIX=$(sh "${PY_UTIL}" get_segment "${URL}" "/" "-1")
          PREFIX=$(sh "${PY_UTIL}" get_segment "${PREFIX}" "." "0")
        {{ end }}
        NAME="{{ if .GetKwarg "name" }}{{ .GetKwarg "name" }}{{ else }}${PREFIX}{{ end }}"
        sh "${PY_UTIL}" set_project_kwarg "subrepo::${NAME}::prefix" "${PREFIX}"
        sh "${PY_UTIL}" set_project_kwarg "subrepo::${NAME}::url" "${URL}"
        echo üéâüéâüéâ
        echo "{{ $d.Bold }}{{ $d.Yellow }}Subrepo ${NAME} has been added{{ $d.Normal }}"


  pushSubrepos:
    icon: üîº
    description: |
      Publish subrepositories.
      USAGE:
        zaruba please pushSubrepos
      ARGUMENTS:
        subrepo::<name>::prefix: Prefix (directory name) of the subrepo
        subrepo::<name>::url:    Remote url of the subrepo
    extend: core.runCoreScript
    dependencies:
    - initSubrepos
    - updateLinks
    - core.setupPyUtil
    config:
      start: |
        {{ $d := .Decoration -}}
        {{ $names := .GetKwargSubKeys "subrepo" -}}
        {{ $this := . -}}
        BRANCH="{{ if .GetKwarg "defaultBranch" }}{{ .GetKwarg "defaultBranch" }}{{ else }}main{{ end }}"
        ORIGINS=$(git remote)
        {{ range $index, $name := $names -}}
          PREFIX="{{ $this.GetKwarg "subrepo" $name "prefix" }}"
          URL="{{ $this.GetKwarg "subrepo" $name "url" }}"
          NAME="{{ $name }}"
          ORIGIN_EXISTS=$(sh "${PY_UTIL}" is_in_array "${NAME}" ${ORIGINS})
          if [ $ORIGIN_EXISTS = 1 ]
          then
            sh "${UTIL}/git_save.sh" "Save works before push"
            git subtree push --prefix="${PREFIX}" "${NAME}" "${BRANCH}"
          fi
        {{ end -}}
        echo üéâüéâüéâ
        echo "{{ $d.Bold }}{{ $d.Yellow }}Subrepos pushed{{ $d.Normal }}"


  pullSubrepos:
    icon: üîΩ
    description: |
      Pull subrepositories.
      USAGE:
        zaruba please pullSubrepos
      ARGUMENTS:
        subrepo::<name>::prefix: Prefix (directory name) of the subrepo
        subrepo::<name>::url:    Remote url of the subrepo
    extend: core.runCoreScript
    dependencies:
    - initSubrepos
    config:
      start: |
        {{ $d := .Decoration -}}
        {{ $names := .GetKwargSubKeys "subrepo" -}}
        {{ $this := . -}}
        ORIGINS=$(git remote)
        BRANCH="{{ if .GetKwarg "defaultBranch" }}{{ .GetKwarg "defaultBranch" }}{{ else }}main{{ end }}"
        {{ range $index, $name := $names -}}
          PREFIX="{{ $this.GetKwarg "subrepo" $name "prefix" }}"
          URL="{{ $this.GetKwarg "subrepo" $name "url" }}"
          NAME="{{ $name }}"
          ORIGIN_EXISTS=$(sh "${PY_UTIL}" is_in_array "${NAME}" ${ORIGINS})
          if [ $ORIGIN_EXISTS = 1 ]
          then
            sh "${UTIL}/git_save.sh" "Save works before pull"
            git subtree pull --prefix="${PREFIX}" "${NAME}" "${BRANCH}"
          fi
        {{ end -}}
        echo üéâüéâüéâ
        echo "{{ $d.Bold }}{{ $d.Yellow }}Subrepos pulled{{ $d.Normal }}"


  core.isProject:
    icon: üîé
    private: true
    extend: core.runCoreScript
    config:
      start: |
        {{ $d := .Decoration -}}
        sh "${UTIL}/should_be_file.sh" "main.zaruba.yaml" "{{ $d.Bold }}{{ $d.Red }}$(pwd) is not a zaruba project.{{ $d.Normal }}"
        echo "{{ $d.Bold }}{{ $d.Yellow }}Current directory is a valid zaruba project{{ $d.Normal }}"


  core.isNotProject:
    icon: üîé
    private: true
    extend: core.runCoreScript
    config:
      start: |
        {{ $d := .Decoration -}}
        sh "${UTIL}/should_not_be_file.sh" "main.zaruba.yaml" "{{ $d.Bold }}{{ $d.Red }}$(pwd) is a zaruba project.{{ $d.Normal }}"
        echo "{{ $d.Bold }}{{ $d.Yellow }}Current directory is not a zaruba project{{ $d.Normal }}"


  initProject:
    icon: üöß
    description: |
      Initiate empty zaruba project.
      USAGE:
        zaruba please initProject
    extend: core.runCoreScript
    dependencies:
    - core.isNotProject
    config:
      start: |
        {{ $d := .Decoration -}}
        git init
        cp -rT "${ZARUBA_HOME}/scripts/templates/project/" .
        echo üéâüéâüéâ
        echo "{{ $d.Bold }}{{ $d.Yellow }}Project created{{ $d.Normal }}"


  updateEnv:
    icon: üîÑ
    description: |
      Update environment of every task in the current project 
      USAGE:
        zaruba please updateEnv
        zaruba please updateEnv dir=.
      ARGUMENT:
        dir:  Directory name
    extend: core.runCoreScript
    dependencies:
    - core.isProject
    - core.setupPyUtil
    config:
      start: |
        {{ $d := .Decoration -}}
        DIR="{{ if .GetKwarg "dir" }}{{ .GetKwarg "dir" }}{{ else }}.{{ end }}"
        sh "${PY_UTIL}" update_env "${DIR}"
        echo üéâüéâüéâ
        echo "{{ $d.Bold }}{{ $d.Yellow }}Environment updated{{ $d.Normal }}"


  updateLinks:
    icon: üîó
    description: |
      Update "links" in your project. Very useful if you have multiple apps sharing some parts of code
      USAGE:
        zaruba please updateLinks
        zaruba please updateLinks "link::fibo/css=common-css"
        zaruba please updateLinks "link::app/css=common-css"
      ARGUMENTS
        link::<destination>:  Location of the shared code
      TIPS:
        It is recommended to put `link` arguments in `default.kwargs.yaml`.
        In order to do that, you can invoke `zaruba please addLink <from=source-location> <to=destination-location>`
    extend: core.runCoreScript
    config:
      start: |
        {{ $d := .Decoration -}}
        {{ $this := . -}}
        {{ $workPath := .WorkPath }}
        {{ $destinations := .GetKwargSubKeys "link" -}}
        {{ range $index, $destination := $destinations -}}
          {{ $source := $this.GetKwarg "link" $destination -}}
          {{ $absSource := $this.GetAbsPath $workPath $source -}}
          {{ $absDestination := $this.GetAbsPath $workPath $destination -}}
          sh "${UTIL}/link_resource.sh" "{{ $absSource }}" "{{ $absDestination }}"
        {{ end -}}
        echo üéâüéâüéâ
        echo "{{ $d.Bold }}{{ $d.Yellow }}Links updated{{ $d.Normal }}"


  addLink:
    icon: üîó
    description: |
      Add link.
      USAGE:
        zaruba please addLink from="common-css" to="fibo/css"
      ARGUMENTS:
        from:   Source Location. (required)
        to:     Destination Location (required)
      TIPS:
        To update links, you should perform `zaruba please updateLinks`
    extend: core.runCoreScript
    dependencies:
    - core.isProject
    - core.setupPyUtil
    config:
      start: |
        {{ $d := .Decoration -}}
        SOURCE="{{ .GetKwarg "from" }}"
        sh "${UTIL}/should_not_be_empty.sh" "${SOURCE}" "{{ $d.Bold }}{{ $d.Red }}'from' argument is not defined{{ $d.Normal }}"
        DESTINATION="{{ .GetKwarg "to" }}"
        sh "${UTIL}/should_not_be_empty.sh" "${DESTINATION}" "{{ $d.Bold }}{{ $d.Red }}'to' argument is not defined{{ $d.Normal }}"
        sh "${PY_UTIL}" set_project_kwarg "link::${DESTINATION)" "${SOURCE}"
        echo üéâüéâüéâ
        echo "{{ $d.Bold }}{{ $d.Yellow }}Link ${SOURCE} -> ${DESTINATION} has been added{{ $d.Normal }}"

  setKwarg:
    icon: üîó
    description: |
      Add link.
      USAGE:
        zaruba please setKwarg key="key" value="value"
      ARGUMENTS:
        key:    Key. (required)
        value:  Value. (required)
    extend: core.runCoreScript
    dependencies:
    - core.isProject
    - core.setupPyUtil
    config:
      start: |
        {{ $d := .Decoration -}}
        KEY="{{ .GetKwarg "key" }}"
        sh "${UTIL}/should_not_be_empty.sh" "${KEY}" "{{ $d.Bold }}{{ $d.Red }}'key' argument is not defined{{ $d.Normal }}"
        VALUE="{{ .GetKwarg "value" }}"
        sh "${UTIL}/should_not_be_empty.sh" "${VALUE}" "{{ $d.Bold }}{{ $d.Red }}'value' argument is not defined{{ $d.Normal }}"
        sh "${PY_UTIL}" set_project_kwarg "${KEY}" "${VALUE}"
        echo üéâüéâüéâ
        echo "{{ $d.Bold }}{{ $d.Yellow }}Kwarg ${KEY} : ${VALUE} has been set{{ $d.Normal }}"


  core.buildDockerImage:
    icon: üê≥
    private: true
    description: |
      Build docker image.
      USAGE:
      ```yaml
      buildMyImage:
        location: ../myLocation
        config:
          # Service name, if not provided will be derived from location
          service: myService
      ```
      ARGUMENTS:
        dockerRepo:   Docker repository. (optional, default to 'local')
    extend: core.runCoreScript
    dependencies:
    - core.setupPyUtil
    - updateLinks
    config:
      start: |
        {{ $d := .Decoration -}}
        sh "${UTIL}/should_be_file.sh" "$(pwd)/Dockerfile" "{{ $d.Bold }}{{ $d.Red }}'Dockerfile' should be exist{{ $d.Normal }}"
        DOCKER_REPO="{{ if .GetKwarg "dockerRepo" }}{{ .GetKwarg "dockerRepo" }}{{ else }}local{{ end }}"
        SERVICE="{{ if .GetConfig "service" }}{{ .GetConfig "service" }}{{ else }}$(sh "${PY_UTIL}" get_service_name "$(pwd)"){{ end }}"
        COMMIT="$(sh "${UTIL}/get_latest_git_commit.sh")"
        sh "${UTIL}/should_not_be_empty.sh" "${COMMIT}" "{{ $d.Bold }}{{ $d.Red }}No commit found{{ $d.Normal }}"
        SHORT_COMMIT="$(echo "${COMMIT}" | cut -c1-12)"
        TAG="$(sh "${UTIL}/get_latest_git_tag.sh")"
        if [ ! -z "${TAG}" ]
        then
          TAG_COMMIT="$(sh "${UTIL}/get_latest_git_tag_commit.sh")"
          if [ "${TAG_COMMIT}" = "${COMMIT}" ]
          then
            echo "{{ $d.Bold }}{{ $d.Yellow }}Build ${DOCKER_REPO}/${SERVICE}:latest, ${DOCKER_REPO}/${SERVICE}:${TAG}, and ${DOCKER_REPO}/${SERVICE}/${SHORT_COMMIT}{{ $d.Normal }}"
            docker build -t "local/${SERVICE}:latest" -t "${DOCKER_REPO}/${SERVICE}:latest" -t "${DOCKER_REPO}/${SERVICE}:${TAG}" -t "${DOCKER_REPO}/${SERVICE}:${SHORT_COMMIT}" .
            echo üéâüéâüéâ
            echo "{{ $d.Bold }}{{ $d.Yellow }}Docker image built{{ $d.Normal }}"
            exit 0
          fi
        fi
        echo "{{ $d.Bold }}{{ $d.Yellow }}Build ${DOCKER_REPO}/${SERVICE}:latest and ${DOCKER_REPO}/${SERVICE}/${SHORT_COMMIT}{{ $d.Normal }}"
        docker build -t "local/${SERVICE}:latest" -t "${DOCKER_REPO}/${SERVICE}:latest" -t "${DOCKER_REPO}/${SERVICE}:${SHORT_COMMIT}" .
        echo üéâüéâüéâ
        echo "{{ $d.Bold }}{{ $d.Yellow }}Docker image built{{ $d.Normal }}"


  core.pushDockerImage:
    icon: üê≥
    private: true
    description: |
      Build docker image.
      USAGE:
      ```yaml
      buildMyImage:
        location: ../myLocation
        config:
          # Service name, if not provided will be derived from location
          service: myService
      ```
      ARGUMENTS:
        dockerRepo:   Docker repository. (required)
    extend: core.runCoreScript
    dependencies:
    - core.setupPyUtil
    - updateLinks
    config:
      start: |
        {{ $d := .Decoration -}}
        DOCKER_REPO="{{ .GetKwarg "dockerRepo" }}"
        sh "${UTIL}/should_not_be_empty.sh" "${DOCKER_REPO}" "{{ $d.Bold }}{{ $d.Red }}'dockerRepo' is required{{ $d.Normal }}"
        SERVICE="{{ if .GetConfig "service" }}{{ .GetConfig "service" }}{{ else }}$(sh "${PY_UTIL}" get_service_name "$(pwd)"){{ end }}"
        COMMIT="$(sh "${UTIL}/get_latest_git_commit.sh")"
        sh "${UTIL}/should_not_be_empty.sh" "${COMMIT}" "{{ $d.Bold }}{{ $d.Red }}No commit found{{ $d.Normal }}"
        SHORT_COMMIT="$(echo "${COMMIT}" | cut -c1-12)"
        TAG="$(sh "${UTIL}/get_latest_git_tag.sh")"
        if [ ! -z "${TAG}" ]
        then
          TAG_COMMIT="$(sh "${UTIL}/get_latest_git_tag_commit.sh")"
          if [ "${TAG_COMMIT}" = "${COMMIT}" ]
          then
            echo "{{ $d.Bold }}{{ $d.Yellow }}Push ${DOCKER_REPO}/${SERVICE}:${TAG}{{ $d.Normal }}"
            docker push "${DOCKER_REPO}/${SERVICE}:${TAG}"
          fi
        fi
        echo "{{ $d.Bold }}{{ $d.Yellow }}Push ${DOCKER_REPO}/${SERVICE}:latest{{ $d.Normal }}"
        docker push "${DOCKER_REPO}/${SERVICE}:latest"
        echo "{{ $d.Bold }}{{ $d.Yellow }}Push ${DOCKER_REPO}/${SERVICE}:${SHORT_COMMIT}{{ $d.Normal }}"
        docker push "${DOCKER_REPO}/${SERVICE}:${SHORT_COMMIT}"
        echo üéâüéâüéâ
        echo "{{ $d.Bold }}{{ $d.Yellow }}Docker image pushed{{ $d.Normal }}"
    

  core.removeDockerContainer:
    icon: üê≥
    private: true
    description: |
      Remove docker container.
      USAGE:
      ```yaml
      removeMyContainer:
        location: ../myLocation
        config:
          # container name, if not provided will be derived from location
          containerName: myContainer
      ```
      ARGUMENTS:
        dockerRepo:   Docker repository. (required)
    extend: core.runCoreScript
    dependencies:
    - core.setupPyUtil
    - updateLinks
    config:
      start: |
        {{ $d := .Decoration -}}
        CONTAINER="{{ if .GetConfig "containerName" }}{{ .GetConfig "containerName" }}{{ else }}$(sh "${PY_UTIL}" get_service_name "$(pwd)"){{ end }}"
        echo "{{ $d.Bold }}{{ $d.Yellow }}Remove docker container ${CONTAINER}{{ $d.Normal }}"
        sh "${UTIL}/stop_and_remove_container.sh" "${CONTAINER}" 
        echo üéâüéâüéâ
        echo "{{ $d.Bold }}{{ $d.Yellow }}Docker container removed{{ $d.Normal }}"
